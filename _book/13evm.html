
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Chapter 13: The Ethereum Virtual Machine Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="14consensus.html" />
    
    
    <link rel="prev" href="12dapps.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="preface.html">
            
                <a href="preface.html">
            
                    
                    Preface
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="glossary.html">
            
                <a href="glossary.html">
            
                    
                    Quick Glossary
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="01what-is.html">
            
                <a href="01what-is.html">
            
                    
                    Chapter 1: What Is Ethereum?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="02intro.html">
            
                <a href="02intro.html">
            
                    
                    Chapter 2: Ethereum Basics
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="03clients.html">
            
                <a href="03clients.html">
            
                    
                    Chapter 3: Ethereum Clients
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="04keys-addresses.html">
            
                <a href="04keys-addresses.html">
            
                    
                    Chapter 4: Cryptography
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="05wallets.html">
            
                <a href="05wallets.html">
            
                    
                    Chapter 5: Wallets
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="06transactions.html">
            
                <a href="06transactions.html">
            
                    
                    Chapter 6: Transactions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="07smart-contracts-solidity.html">
            
                <a href="07smart-contracts-solidity.html">
            
                    
                    Chapter 7: Smart Contracts and Solidity
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="08smart-contracts-vyper.html">
            
                <a href="08smart-contracts-vyper.html">
            
                    
                    Chapter 8: Smart Contracts and Vyper
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="09smart-contracts-security.html">
            
                <a href="09smart-contracts-security.html">
            
                    
                    Chapter 9: Smart Contract Security
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="10tokens.html">
            
                <a href="10tokens.html">
            
                    
                    Chapter 10: Tokens
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="11oracles.html">
            
                <a href="11oracles.html">
            
                    
                    Chapter 11: Oracles
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="12dapps.html">
            
                <a href="12dapps.html">
            
                    
                    Chapter 12: Decentralized Applications (DApps)
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.16" data-path="13evm.html">
            
                <a href="13evm.html">
            
                    
                    Chapter 13: The Ethereum Virtual Machine
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="14consensus.html">
            
                <a href="14consensus.html">
            
                    
                    Chapter 14: Consensus
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="appdx-forks-history.html">
            
                <a href="appdx-forks-history.html">
            
                    
                    Appendix A: Ethereum Fork History
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="appdx-standards-eip-erc.html">
            
                <a href="appdx-standards-eip-erc.html">
            
                    
                    Appendix A: Ethereum Standards
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="appdx-evm-opcodes-gas.html">
            
                <a href="appdx-evm-opcodes-gas.html">
            
                    
                    Appendix A: Ethereum EVM Opcodes and Gas Consumption
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="appdx-dev-tools.html">
            
                <a href="appdx-dev-tools.html">
            
                    
                    Appendix A: Development Tools, Frameworks, and Libraries
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="6.1" data-path="appdx-web3js-tutorial.html">
            
                <a href="appdx-web3js-tutorial.html">
            
                    
                    Appendix A: web3.js Tutorial
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Chapter 13: The Ethereum Virtual Machine</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <div class="sect1">
<h2 id="evm_chapter">The Ethereum Virtual Machine</h2>
<div class="sectionbody">
<div class="paragraph">
<p>At the heart of the Ethereum protocol and operation is the Ethereum Virtual Machine, or EVM for short. As you might guess from the name, it is a computation engine, not hugely dissimilar to the virtual machines of Microsoft&#x2019;s .NET Framework, or interpreters of other bytecode-compiled programming languages such as Java. In this chapter we take a detailed look at the EVM, including its instruction set, structure, and operation, within the context of Ethereum state updates.</p>
</div>
<div class="sect2">
<h3 id="evm_description">What Is the EVM?</h3>
<div class="paragraph">
<p>The EVM is the part of Ethereum that handles smart contract deployment and execution. Simple value transfer transactions from one EOA to another don&#x2019;t need to involve it, practically speaking, but everything else will involve a state update computed by the EVM. At a high level, the EVM running on the Ethereum blockchain can be thought of as a global decentralized computer containing millions of executable objects, each with its own permanent data store.</p>
</div>
<div class="paragraph">
<p>The EVM is a quasi&#x2013;Turing-complete state machine; &quot;quasi&quot; because all execution processes are limited to a finite number of computational steps by the amount of gas available for any given smart contract execution. As such, the halting problem is &quot;solved&quot; (all program executions will halt) and the situation where execution might (accidentally or maliciously) run forever, thus bringing the Ethereum platform to halt in its entirety, is avoided.</p>
</div>
<div class="paragraph">
<p>The EVM has a stack-based architecture, storing all in-memory values on a stack. It works with a word size of 256 bits (mainly to facilitate native hashing and elliptic curve operations) and has several addressable data components:</p>
</div>
<div class="ulist pagebreak-before">
<ul>
<li>
<p>An immutable <em>program code ROM</em>, loaded with the bytecode of the smart contract to be executed</p>
</li>
<li>
<p>A volatile <em>memory</em>, with every location explicitly initialized to zero</p>
</li>
<li>
<p>A permanent <em>storage</em> that is part of the Ethereum state, also zero-initialized</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is also a set of environment variables and data that is available during execution. We will go through these in more detail later in this chapter.</p>
</div>
<div class="paragraph">
<p><a href="#evm_architecture">The Ethereum Virtual Machine (EVM) Architecture and Execution Context</a> shows the EVM architecture and execution context.</p>
</div>
<div id="evm_architecture" class="imageblock">
<div class="content">
<img src="images/evm-architecture.png" alt="The Ethereum Virtual Machine (EVM) Architecture and Execution Context">
</div>
<div class="title">Figure 1. The Ethereum Virtual Machine (EVM) Architecture and Execution Context</div>
</div>
<div class="sect3">
<h4 id="evm_comparison">Comparison with Existing Technology</h4>
<div class="paragraph">
<p>The term &quot;virtual machine&quot; is often applied to the virtualization of a real computer, typically by a &quot;hypervisor&quot; such as VirtualBox or QEMU, or of an entire operating system instance, such as Linux&#x2019;s KVM. These must provide a software abstraction, respectively, of actual hardware, and of system calls and other kernel functionality.</p>
</div>
<div class="paragraph">
<p>The EVM operates in a much more limited domain: it is just a computation engine, and as such provides an abstraction of just computation and storage, similar to the Java Virtual Machine (JVM) specification, for example. From a high-level viewpoint, the JVM is designed to provide a runtime environment that is agnostic of the underlying host OS or hardware, enabling compatibility across a wide variety of systems. High-level programming languages such as Java or Scala (which use the JVM) or C# (which uses .NET) are compiled into the bytecode instruction set of their respective virtual machine. In the same way, the EVM executes its own bytecode instruction set (described in the next section), which higher-level smart contract programming languages such as LLL, Serpent, Mutan, or Solidity are compiled into.</p>
</div>
<div class="paragraph">
<p>The EVM, therefore, has no scheduling capability, because execution ordering is organized externally to it&#x2014;Ethereum clients run through verified block transactions to determine which smart contracts need executing and in which order. In this sense, the Ethereum world computer is single-threaded, like JavaScript. Neither does the EVM have any &quot;system interface&quot; handling or &#x201C;hardware support&#x201D;&#x2014;there is no physical machine to interface with. The Ethereum world computer is completely virtual.</p>
</div>
</div>
<div class="sect3">
<h4 id="evm_bytecode_overview">The EVM Instruction Set (Bytecode Operations)</h4>
<div class="paragraph">
<p>The EVM instruction set offers most of the operations you might expect, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Arithmetic and bitwise logic operations</p>
</li>
<li>
<p>Execution context inquiries</p>
</li>
<li>
<p>Stack, memory, and storage access</p>
</li>
<li>
<p>Control flow operations</p>
</li>
<li>
<p>Logging, calling, and other operators</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition to the typical bytecode operations, the EVM also has access to account information (e.g., address and balance) and block information (e.g., block number and current gas price).</p>
</div>
<div class="paragraph">
<p>Let&#x2019;s start our exploration of the EVM in more detail by looking at the available opcodes and what they do. As you might expect, all operands are taken from the stack, and the result (where applicable) is often
put back on the top of the stack.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>A complete list of opcodes and their corresponding gas cost can be found in <a href="#evm_opcodes">[evm_opcodes]</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The available opcodes can be divided into the following categories:</p>
</div>
<div id="arithmetic_opcodes" class="dlist">
<dl>
<dt class="hdlist1">Arithmetic operations</dt>
<dd>
<p>Arithmetic opcode instructions:</p>
<div class="listingblock">
<div class="content">
<pre>ADD        //Add the top two stack items
MUL        //Multiply the top two stack items
SUB        //Subtract the top two stack items
DIV        //Integer division
SDIV       //Signed integer division
MOD        //Modulo (remainder) operation
SMOD       //Signed modulo operation
ADDMOD     //Addition modulo any number
MULMOD     //Multiplication modulo any number
EXP        //Exponential operation
SIGNEXTEND //Extend the length of a two&apos;s complement signed integer
SHA3       //Compute the Keccak-256 hash of a block of memory</pre>
</div>
</div>
<div class="paragraph">
<p>Note that all arithmetic is performed modulo 2<sup>256</sup> (unless otherwise noted), and that the zeroth power of zero, 0<sup>0</sup>, is taken to be 1.</p>
</div>
</dd>
</dl>
</div>
<div id="stack_opcodes" class="dlist">
<dl>
<dt class="hdlist1">Stack operations</dt>
<dd>
<p>Stack, memory, and storage management instructions:</p>
<div class="listingblock">
<div class="content">
<pre>POP     //Remove the top item from the stack
MLOAD   //Load a word from memory
MSTORE  //Save a word to memory
MSTORE8 //Save a byte to memory
SLOAD   //Load a word from storage
SSTORE  //Save a word to storage
MSIZE   //Get the size of the active memory in bytes
PUSHx   //Place x byte item on the stack, where x can be any integer from
        // 1 to 32 (full word) inclusive
DUPx    //Duplicate the x-th stack item, where x can be any integer from
        // 1 to 16 inclusive
SWAPx   //Exchange 1st and (x+1)-th stack items, where x can be any
        // integer from 1 to 16 inclusive</pre>
</div>
</div>
</dd>
</dl>
</div>
<div id="flow_opcodes" class="dlist">
<dl>
<dt class="hdlist1">Process flow operations</dt>
<dd>
<p>Instructions for control flow:</p>
<div class="listingblock">
<div class="content">
<pre>STOP      //Halt execution
JUMP      //Set the program counter to any value
JUMPI     //Conditionally alter the program counter
PC        //Get the value of the program counter (prior to the increment
          //corresponding to this instruction)
JUMPDEST  //Mark a valid destination for jumps</pre>
</div>
</div>
</dd>
</dl>
</div>
<div id="system_opcodes" class="dlist">
<dl>
<dt class="hdlist1">System operations</dt>
<dd>
<p>Opcodes for the system executing the program:</p>
<div class="listingblock">
<div class="content">
<pre>LOGx          //Append a log record with x topics, where x is any integer
              //from 0 to 4 inclusive
CREATE        //Create a new account with associated code
CALL          //Message-call into another account, i.e. run another
              //account&apos;s code
CALLCODE      //Message-call into this account with another
              //account&apos;s code
RETURN        //Halt execution and return output data
DELEGATECALL  //Message-call into this account with an alternative
              //account&apos;s code, but persisting the current values for
              //sender and value
STATICCALL    //Static message-call into an account
REVERT        //Halt execution, reverting state changes but returning
              //data and remaining gas
INVALID       //The designated invalid instruction
SELFDESTRUCT  //Halt execution and register account for deletion</pre>
</div>
</div>
</dd>
</dl>
</div>
<div id="logic_opcides" class="dlist">
<dl>
<dt class="hdlist1">Logic operations</dt>
<dd>
<p>Opcodes for comparisons and bitwise logic:</p>
<div class="listingblock">
<div class="content">
<pre>LT     //Less-than comparison
GT     //Greater-than comparison
SLT    //Signed less-than comparison
SGT    //Signed greater-than comparison
EQ     //Equality comparison
ISZERO //Simple NOT operator
AND    //Bitwise AND operation
OR     //Bitwise OR operation
XOR    //Bitwise XOR operation
NOT    //Bitwise NOT operation
BYTE   //Retrieve a single byte from a full-width 256-bit word</pre>
</div>
</div>
</dd>
</dl>
</div>
<div id="environment_opcodes" class="dlist">
<dl>
<dt class="hdlist1">Environmental operations</dt>
<dd>
<p>Opcodes dealing with execution environment information:</p>
<div class="listingblock">
<div class="content">
<pre>GAS            //Get the amount of available gas (after the reduction for
               //this instruction)
ADDRESS        //Get the address of the currently executing account
BALANCE        //Get the account balance of any given account
ORIGIN         //Get the address of the EOA that initiated this EVM
               //execution
CALLER         //Get the address of the caller immediately responsible
               //for this execution
CALLVALUE      //Get the ether amount deposited by the caller responsible
               //for this execution
CALLDATALOAD   //Get the input data sent by the caller responsible for
               //this execution
CALLDATASIZE   //Get the size of the input data
CALLDATACOPY   //Copy the input data to memory
CODESIZE       //Get the size of code running in the current environment
CODECOPY       //Copy the code running in the current environment to
               //memory
GASPRICE       //Get the gas price specified by the originating
               //transaction
EXTCODESIZE    //Get the size of any account&apos;s code
EXTCODECOPY    //Copy any account&apos;s code to memory
RETURNDATASIZE //Get the size of the output data from the previous call
               //in the current environment
RETURNDATACOPY //Copy data output from the previous call to memory</pre>
</div>
</div>
</dd>
</dl>
</div>
<div id="block_opcodes" class="dlist">
<dl>
<dt class="hdlist1">Block operations</dt>
<dd>
<p>Opcodes for accessing information on the current block:</p>
<div class="listingblock">
<div class="content">
<pre>BLOCKHASH  //Get the hash of one of the 256 most recently completed
           //blocks
COINBASE   //Get the block&apos;s beneficiary address for the block reward
TIMESTAMP  //Get the block&apos;s timestamp
NUMBER     //Get the block&apos;s number
DIFFICULTY //Get the block&apos;s difficulty
GASLIMIT   //Get the block&apos;s gas limit</pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="evm_state_descriptions">Ethereum State</h4>
<div class="paragraph">
<p>The job of the EVM is to update the Ethereum state by computing valid state transitions as a result of smart contract code execution, as defined by the Ethereum protocol. This aspect leads to the description of Ethereum as a <em>transaction-based state machine</em>, which reflects the fact that external actors (i.e., account holders and miners) initiate state transitions by creating, accepting, and ordering transactions. It is useful at this point to consider what constitutes the Ethereum state.</p>
</div>
<div class="paragraph">
<p>At the top level, we have the Ethereum <em>world state</em>. The world state is a mapping of Ethereum addresses (160-bit values) to <em>accounts</em>. At the lower level, each Ethereum address represents an account comprising an ether <em>balance</em> (stored as the number of wei owned by the account), a <em>nonce</em> (representing the number of transactions successfully sent from this account if it is an EOA, or the number of contracts created by it if it is a contract account), the account&#x2019;s <em>storage</em> (which is a permanent data store, only used by smart contracts), and the account&#x2019;s <em>program code</em> (again, only if the account is a smart contract account). An EOA will always have no code and an empty storage.</p>
</div>
<div class="paragraph">
<p>When a transaction results in smart contract code execution, an EVM is instantiated with all the information required in relation to the current block being created and the specific transaction being processed. In particular, the EVM&#x2019;s program code ROM is loaded with the code of the contract account being called, the program counter is set to zero, the storage is loaded from the contract account&#x2019;s storage, the memory is set to all zeros, and all the block and environment variables are set. A key variable is the gas supply for this execution, which is set to the amount of gas paid for by the sender at the start of the transaction (see <a href="#gas">Gas</a> for more details). As code execution progresses, the gas supply is reduced according to the gas cost of the operations executed. If at any point the gas supply is reduced to zero we get an &quot;Out of Gas&quot; (OOG) exception; execution immediately halts and the transaction is abandoned. No changes to the Ethereum state are applied, except for the sender&#x2019;s nonce being incremented and their ether balance going down to pay the block&#x2019;s beneficiary for the resources used to execute the code to the halting point. At this point, you can think of the EVM running on a sandboxed copy of the Ethereum world state, with this sandboxed version being discarded completely if execution cannot complete for whatever reason. However, if execution does complete successfully, then the real-world state is updated to match the sandboxed version, including any changes to the called contract&#x2019;s storage data, any new contracts created, and any ether balance transfers that were initiated.</p>
</div>
<div class="paragraph">
<p>Note that because a smart contract can itself effectively initiate transactions, code execution is a recursive process. A contract can call other contracts, with each call resulting in another EVM being instantiated around the new target of the call. Each instantiation has its sandbox world state initialized from the sandbox of the EVM at the level above. Each instantiation is also given a specified amount of gas for its gas supply (not exceeding the amount of gas remaining in the level above, of course), and so may itself halt with an exception due to being given too little gas to complete its execution. Again, in such cases, the sandbox state is discarded, and execution returns to the EVM at the level above.</p>
</div>
</div>
<div class="sect3">
<h4 id="compiling_solidity_to_evm">Compiling Solidity to EVM Bytecode</h4>
<div id="solc_help" class="paragraph">
<p>Compiling a Solidity source file to EVM bytecode can be accomplished via several methods. In <a href="#intro_chapter">[intro_chapter]</a> we used the online Remix compiler. In this chapter, we will use the solc executable at the command line. For a list of options, run the following <span class="keep-together">command</span>:</p>
</div>
<pre data-type="programlisting">
$ <strong>solc --help</strong>
</pre>
<div id="solc_opcodes_option" class="paragraph">
<p>Generating the raw opcode stream of a Solidity source file is easily achieved with the --opcodes command-line option. This opcode stream leaves out some information (the --asm option produces the full information), but it is sufficient for this discussion. For example, compiling an example Solidity file, <em>Example.sol</em>, and sending the opcode output into a directory named <em>BytecodeDir</em> is accomplished with the following command:</p>
</div>
<pre data-type="programlisting">
$ <strong>solc -o BytecodeDir --opcodes Example.sol</strong>
</pre>
<div class="paragraph">
<p>or:</p>
</div>
<pre data-type="programlisting">
$ <strong>solc -o BytecodeDir --asm Example.sol</strong>
</pre>
<div id="solc_bin_option" class="paragraph">
<p>The following command will produce the bytecode binary for our example program:</p>
</div>
<pre data-type="programlisting">
$ <strong>solc -o BytecodeDir --bin Example.sol</strong>
</pre>
<div class="paragraph">
<p>The output opcode files generated will depend on the specific contracts contained within the Solidity source file. Our simple Solidity file <em>Example.sol</em> has only one contract, named example:</p>
</div>
<div id="simple_solidity_example" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">pragma solidity ^0.4.19;

contract example {

  address contractOwner;

  function example() {
    contractOwner = msg.sender;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, all this contract does is hold one persistent state variable, which is set as the address of the last account to run this contract.</p>
</div>
<div class="paragraph">
<p>If you look in the <em>BytecodeDir</em> directory you will see the opcode file <em>example.opcode</em>, which contains the EVM opcode instructions of the example contract. Opening the <em>example.opcode</em> file in a text editor will show the following:</p>
</div>
<div id="opcode_output" class="listingblock">
<div class="content">
<pre>PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH1 0xE JUMPI PUSH1 0x0 DUP1
REVERT JUMPDEST CALLER PUSH1 0x0 DUP1 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH20
0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH20
0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP PUSH1
0x35 DUP1 PUSH1 0x5B PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x60 PUSH1
0x40 MSTORE PUSH1 0x0 DUP1 REVERT STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 JUMP
0xb9 SWAP14 0xcb 0x1e 0xdd RETURNDATACOPY 0xec 0xe0 0x1f 0x27 0xc9 PUSH5
0x9C5ABCC14A NUMBER 0x5e INVALID EXTCODESIZE 0xdb 0xcf EXTCODESIZE 0x27
EXTCODESIZE 0xe2 0xb8 SWAP10 0xed 0x</pre>
</div>
</div>
<div class="paragraph">
<p>Compiling the example with the --asm option produces a file named <em>example.evm</em> in our <em>BytecodeDir</em> directory. This contains a slightly higher-level description of the EVM bytecode instructions, together with some helpful annotations:</p>
</div>
<div id="asm_output" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">/* &quot;Example.sol&quot;:26:132  contract example {... */
  mstore(0x40, 0x60)
    /* &quot;Example.sol&quot;:74:130  function example() {... */
  jumpi(tag_1, iszero(callvalue))
  0x0
  dup1
  revert
tag_1:
    /* &quot;Example.sol&quot;:115:125  msg.sender */
  caller
    /* &quot;Example.sol&quot;:99:112  contractOwner */
  0x0
  dup1
    /* &quot;Example.sol&quot;:99:125  contractOwner = msg.sender */
  0x100
  exp
  dup2
  sload
  dup2
  0xffffffffffffffffffffffffffffffffffffffff
  mul
  not
  and
  swap1
  dup4
  0xffffffffffffffffffffffffffffffffffffffff
  and
  mul
  or
  swap1
  sstore
  pop
    /* &quot;Example.sol&quot;:26:132  contract example {... */
  dataSize(sub_0)
  dup1
  dataOffset(sub_0)
  0x0
  codecopy
  0x0
  return
stop

sub_0: assembly {
        /* &quot;Example.sol&quot;:26:132  contract example {... */
      mstore(0x40, 0x60)
      0x0
      dup1
      revert

    auxdata: 0xa165627a7a7230582056b99dcb1edd3eece01f27c9649c5abcc14a435efe3b...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The --bin-runtime option produces the machine-readable hexadecimal bytecode:</p>
</div>
<div id="bin_output" class="listingblock">
<div class="content">
<pre>60606040523415600e57600080fd5b336000806101000a81548173
ffffffffffffffffffffffffffffffffffffffff
021916908373
ffffffffffffffffffffffffffffffffffffffff
160217905550603580605b6000396000f3006060604052600080fd00a165627a7a7230582056b...</pre>
</div>
</div>
<div class="paragraph">
<p>You can investigate what&#x2019;s going on here in detail using the opcode list given in <a href="#evm_bytecode_overview">The EVM Instruction Set (Bytecode Operations)</a>. However, that&#x2019;s quite a task, so let&#x2019;s just start by examining the first four instructions:</p>
</div>
<div id="opcode_analysis_1" class="listingblock">
<div class="content">
<pre>PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE</pre>
</div>
</div>
<div class="paragraph">
<p>Here we have PUSH1 followed by a raw byte of value 0x60. This EVM instruction takes the single byte following the opcode in the program code (as a literal value) and pushes it onto the stack. It is possible to push values of size up to 32 bytes onto the stack, as in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>PUSH32 0x436f6e67726174756c6174696f6e732120536f6f6e20746f206d617374657221</pre>
</div>
</div>
<div class="paragraph">
<p>The second PUSH1 opcode from <em>example.opcode</em> stores 0x40 onto the top of the stack (pushing the 0x60 already present there down one slot).</p>
</div>
<div class="paragraph">
<p>Next is MSTORE, which is a memory store operation that saves a value to the EVM&#x2019;s memory. It takes two arguments and, like most EVM operations, obtains them from the stack. For each argument the stack is &#x201C;popped&#x201D;; i.e., the top value on the stack is taken off and all the other values on the stack are shifted up one position. The first argument for MSTORE is the address of the word in memory where the value to be saved will be put. For this program we have 0x40 at the top of the stack, so that is removed from the stack and used as the memory address. The second argument is the value to be saved, which is 0x60 here. After the MSTORE operation is executed our stack is empty again, but we have the value 0x60 (96 in decimal) at the memory location 0x40.</p>
</div>
<div class="paragraph">
<p>The next opcode is CALLVALUE, which is an environmental opcode that pushes onto the top of the stack the amount of ether (measured in wei) sent with the message call that initiated this execution.</p>
</div>
<div class="paragraph">
<p>We could continue to step through this program in this way until we had a full understanding of the low-level state changes that this code effects, but it wouldn&#x2019;t help us at this stage. We&#x2019;ll come back to it later in the chapter.</p>
</div>
</div>
<div class="sect3">
<h4 id="contract_deployment_code">Contract Deployment Code</h4>
<div class="paragraph">
<p>There is an important but subtle difference between the code used when creating and deploying a new contract on the Ethereum platform and the code of the contract itself. In order to create a new contract, a special transaction is needed that has its to field set to the special 0x0 address and its data field set to the contract&#x2019;s <em>initiation code</em>. When such a contract creation transaction is processed, the code for the new contract account is <em>not</em> the code in the data field of the transaction. Instead, an EVM is instantiated with the code in the data field of the transaction loaded into its program code ROM, and then the output of the execution of that deployment code is taken as the code for the new contract account. This is so that new contracts can be programmatically initialized using the Ethereum world state at the time of deployment, setting values in the contract&#x2019;s storage and even sending ether or creating further new contracts.</p>
</div>
<div class="paragraph">
<p>When compiling a contract offline, e.g., using solc on the command line, you can either get the <em>deployment bytecode</em> or the <em>runtime bytecode</em>.</p>
</div>
<div class="paragraph">
<p>The deployment bytecode is used for every aspect of the initialization of a new contract account, including the bytecode that will actually end up being executed when transactions call this new contract (i.e., the runtime bytecode) and the code to initialize everything based on the contract&#x2019;s constructor.</p>
</div>
<div class="paragraph">
<p>The runtime bytecode, on the other hand, is exactly the bytecode that ends up being executed when the new contract is called, and nothing more; it does not include the bytecode needed to initialize the contract during deployment.</p>
</div>
<div class="paragraph">
<p>Let&#x2019;s take the simple <em>Faucet.sol</em> contract we created earlier as an example:</p>
</div>
<div id="faucet_example" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-solidity" data-lang="solidity">// Version of Solidity compiler this program was written for
pragma solidity ^0.4.19;

// Our first contract is a faucet!
contract Faucet {

  // Give out ether to anyone who asks
  function withdraw(uint withdraw_amount) public {

      // Limit withdrawal amount
      require(withdraw_amount &lt;= 100000000000000000);

      // Send the amount to the address that requested it
      msg.sender.transfer(withdraw_amount);
    }

  // Accept any incoming amount
  function () public payable {}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To get the deployment bytecode, we would run <code>solc --bin Faucet.sol</code>. If we instead wanted just the runtime bytecode, we would run <code>solc --bin-runtime Faucet.sol</code>.</p>
</div>
<div class="paragraph">
<p>If you compare the output of these commands, you will see that the runtime bytecode is a subset of the deployment bytecode. In other words, the runtime bytecode is entirely contained within the deployment bytecode.</p>
</div>
</div>
<div class="sect3">
<h4 id="disassembling_the_bytecode">Disassembling the Bytecode</h4>
<div class="paragraph">
<p>Disassembling EVM bytecode is a great way to understand how high-level Solidity acts in the EVM. There are a few disassemblers you can use to do this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/comaeio/porosity" target="_blank"><em>Porosity</em></a> is a popular open source decompiler.</p>
</li>
<li>
<p><a href="https://github.com/trailofbits/ethersplay" target="_blank"><em>Ethersplay</em></a> is an EVM plug-in for Binary Ninja, a disassembler.</p>
</li>
<li>
<p><a href="https://github.com/trailofbits/ida-evm" target="_blank"><em>IDA-Evm</em></a> is an EVM plugin for IDA, another disassembler.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In this section, we will be using the Ethersplay plug-in for Binary Ninja and to start <a href="#Faucet_disassembled">Disassembling the Faucet runtime bytecode</a>. After getting the runtime bytecode of <em>Faucet.sol</em>, we can feed it into Binary Ninja (after loading the Ethersplay plug-in) to see what the EVM instructions look like.</p>
</div>
<div id="Faucet_disassembled" class="imageblock">
<div class="content">
<img src="images/Faucet_disassembled.png" alt="Faucet.sol runtime bytecode disassembled">
</div>
<div class="title">Figure 2. Disassembling the Faucet runtime bytecode</div>
</div>
<div class="paragraph">
<p>When you send a transaction to an ABI-compatible smart contract (which you can assume all contracts are), the transaction first interacts with that smart contract&#x2019;s <em>dispatcher</em>. The dispatcher reads in the data field of the transaction and sends the relevant part to the appropriate function. We can see an example of a dispatcher at the beginning of our disassembled <em>Faucet.sol</em> runtime bytecode. After the familiar MSTORE instruction, we see the following instructions:</p>
</div>
<div id="faucet_instructions" class="listingblock">
<div class="content">
<pre>PUSH1 0x4
CALLDATASIZE
LT
PUSH1 0x3f
JUMPI</pre>
</div>
</div>
<div class="paragraph">
<p>As we have seen, PUSH1 0x4 places 0x4 onto the top of the stack, which is otherwise empty. CALLDATASIZE gets the size in bytes of the data sent with the transaction (known as the <em>calldata</em>) and pushes that number onto the stack. After these operations have been executed, the stack looks like this:</p>
</div>
<table class="tableblock frame-topbot grid-all" style="width: 40%;">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Stack</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x4</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;length of calldata from tx&gt;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>This next instruction is LT, short for &#x201C;less than.&#x201D; The LT instruction checks whether the top item on the stack is less than the next item on the stack. In our case, it checks to see if the result of CALLDATASIZE is less than 4 bytes.</p>
</div>
<div class="paragraph">
<p>Why does the EVM check to see that the calldata of the transaction is at least 4 bytes? Because of how function identifiers work. Each function is identified by the first 4 bytes of its Keccak-256 hash. By placing the function&#x2019;s name and what arguments it takes into a keccak256 hash function, we can deduce its function identifier. In our case, we have:</p>
</div>
<div id="faucet_function_identifier" class="listingblock">
<div class="content">
<pre class="highlight"><code>keccak256(&quot;withdraw(uint256)&quot;) = 0x2e1a7d4d...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thus, the function identifier for the withdraw(uint256) function is 0x2e1a7d4d, since these are the first 4 bytes of the resulting hash. A function identifier is always 4 bytes long, so if the entire data field of the transaction sent to the contract is less than 4 bytes, then there&#x2019;s no function with which the transaction could possibly be communicating, unless a <em>fallback function</em> is defined. Because we implemented such a fallback function in <em>Faucet.sol</em>, the EVM jumps to this function when the calldata&#x2019;s length is less than 4 bytes.</p>
</div>
<div class="paragraph">
<p>LT pops the top two values off the stack and, if the transaction&#x2019;s data field is less than 4 bytes, pushes 1 onto it. Otherwise, it pushes 0. In our example, let&#x2019;s assume the data field of the transaction sent to our contract <em>was</em> less than 4 bytes.</p>
</div>
<div class="paragraph">
<p>The PUSH1 0x3f instruction pushes the byte 0x3f onto the stack. After this instruction, the stack looks like this:</p>
</div>
<table class="tableblock frame-topbot grid-all" style="width: 40%;">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Stack</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x3f</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The next instruction is JUMPI, which stands for &quot;jump if.&quot; It works like so:</p>
</div>
<div id="faucet_jump_instruction_text" class="listingblock">
<div class="content">
<pre>jumpi(label, cond) // Jump to &quot;label&quot; if &quot;cond&quot; is true</pre>
</div>
</div>
<div class="paragraph">
<p>In our case, label is 0x3f, which is where our fallback function lives in our smart contract. The cond argument is 1, which was the result of the LT instruction earlier. To put this entire sequence into words, the contract jumps to the fallback function if the transaction data is less than 4 bytes.</p>
</div>
<div class="paragraph">
<p>At 0x3f, only a STOP instruction follows, because although we declared a fallback function, we kept it empty. As you can see in <a href="#Faucet_jumpi_instruction">JUMPI instruction leading to fallback function</a>, had we not implemented a fallback function, the contract would throw an exception instead.</p>
</div>
<div id="Faucet_jumpi_instruction" class="imageblock">
<div class="content">
<img src="images/Faucet_jumpi_instruction.png" alt="JUMPI instruction leading to fallback function">
</div>
<div class="title">Figure 3. JUMPI instruction leading to fallback function</div>
</div>
<div class="paragraph">
<p>Let&#x2019;s examine the central block of the dispatcher. Assuming we received calldata that was <em>greater</em> than 4 bytes in length, the JUMPI instruction would not jump to the fallback function. Instead, code execution would proceed to the following instructions:</p>
</div>
<div id="faucet_instructions2" class="listingblock">
<div class="content">
<pre>PUSH1 0x0
CALLDATALOAD
PUSH29 0x1000000...
SWAP1
DIV
PUSH4 0xffffffff
AND
DUP1
PUSH4 0x2e1a7d4d
EQ
PUSH1 0x41
JUMPI</pre>
</div>
</div>
<div class="paragraph">
<p>PUSH1 0x0 pushes 0 onto the stack, which is now otherwise empty again. CALLDATALOAD accepts as an argument an index within the calldata sent to the smart contract and reads 32 bytes from that index, like so:</p>
</div>
<div id="faucet_calldataload_instruction_text" class="listingblock">
<div class="content">
<pre>calldataload(p) //load 32 bytes of calldata starting from byte position p</pre>
</div>
</div>
<div class="paragraph">
<p>Since 0 was the index passed to it from the PUSH1 0x0 command, CALLDATALOAD reads 32 bytes of calldata starting at byte 0, and then pushes it to the top of the stack (after popping the original 0x0). After the PUSH29 0x1000000&#x2026;&#x200B; instruction, the stack is then:</p>
</div>
<table class="tableblock frame-topbot grid-all" style="width: 40%;">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Stack</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;32 bytes of calldata starting at byte 0&gt;</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x1000000&#x2026;&#x200B; (29 bytes in length)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>SWAP1 switches the top element on the stack with the <em>i</em>-th element after it. In this case, it swaps 0x1000000&#x2026;&#x200B; with the calldata. The new stack is:</p>
</div>
<table class="tableblock frame-topbot grid-all" style="width: 40%;">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Stack</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x1000000&#x2026;&#x200B; (29 bytes in length)</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;32 bytes of calldata starting at byte 0&gt;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The next instruction is DIV, which works as follows:</p>
</div>
<div id="faucet_div_instruction_text" class="listingblock">
<div class="content">
<pre>div(x, y) // integer division x / y</pre>
</div>
</div>
<div class="paragraph">
<p>In this case, x = 32 bytes of calldata starting at byte 0, and y = 0x100000000&#x2026;&#x200B; (29 bytes total). Can you think of why the dispatcher is doing the division? Here&#x2019;s a hint: we read 32 bytes from calldata earlier, starting at index 0. The first 4 bytes of that calldata is the function identifier.</p>
</div>
<div class="paragraph">
<p>The 0x100000000&#x2026;&#x200B; we pushed earlier is 29 bytes long, consisting of a 1 at the beginning, followed by all 0s. Dividing our 32 bytes of calldata by this value will leave us only the <em>topmost 4 bytes</em> of our calldata load, starting at index 0. These 4 bytes&#x2014;the first 4 bytes in the calldata starting at index 0&#x2014;are the function identifier, and this is how the EVM extracts that field.</p>
</div>
<div class="paragraph">
<p>If this part isn&#x2019;t clear to you, think of it like this: in base 10, 1234000 / 1000 = 1234. In base 16, this is no different. Instead of every place being a multiple of 10, it is a multiple of 16. Just as dividing by 10<sup>3</sup> (1000) in our smaller example kept only the topmost digits, dividing our 32-byte base 16 value by 16<sup>29</sup> does the same.</p>
</div>
<div class="paragraph">
<p>The result of the DIV (the function identifier) gets pushed onto the stack, and our stack is now:</p>
</div>
<table class="tableblock frame-topbot grid-all" style="width: 40%;">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Stack</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;function identifier sent in data&gt;</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>Since the PUSH4 0xffffffff and AND instructions are redundant, we can ignore them entirely, as the stack will remain the same after they are done. The DUP1 instruction duplicates the first item on the stack, which is the function identifier. The next instruction, PUSH4 0x2e1a7d4d, pushes the precalculated function identifier of the <code>withdraw(uint256)</code> function onto the stack. The stack is now:</p>
</div>
<table class="tableblock frame-topbot grid-all" style="width: 40%;">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Stack</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;function identifier sent in data&gt;</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2e1a7d4d</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;function identifier sent in data&gt;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The next instruction, EQ, pops off the top two items of the stack and compares them. This is where the dispatcher does its main job: it compares whether the function identifier sent in the msg.data field of the transaction matches that of <code>withdraw(uint256)</code>. If they are equal, EQ pushes 1 onto the stack, which will ultimately be used to jump to the withdraw function. Otherwise, EQ pushes 0 onto the stack.</p>
</div>
<div class="paragraph">
<p>Assuming the transaction sent to our contract indeed began with the function identifier for withdraw(uint256), our stack has become:</p>
</div>
<table class="tableblock frame-topbot grid-all" style="width: 40%;">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Stack</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;function identifier sent in data&gt; (now known to be 0x2e1a7d4d)</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Next, we have PUSH1 0x41, which is the address at which the withdraw(uint256) function lives in the contract. After this instruction, the stack looks like this:</p>
</div>
<table class="tableblock frame-topbot grid-all" style="width: 40%;">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Stack</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">function identifier sent in msg.data</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x41</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The JUMPI instruction is next, and it once again accepts the top two elements on the stack as arguments. In this case, we have jumpi(0x41, 1), which tells the EVM to execute the jump to the location of the withdraw(uint256) function, and the execution of that function&#x2019;s code can proceed.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="turing_completeness_and_gas">Turing Completeness and Gas</h3>
<div class="paragraph">
<p>As we have already touched on, in simple terms, a system or programming language is <em>Turing complete</em> if it can run any program. This capability, however, comes with an very important caveat: some programs take forever to run. An important aspect of this is that we can&#x2019;t tell, just by looking at a program, whether it will take forever or not to execute. We have to actually go through with the execution of the program and wait for it to finish to find out. Of course, if it is going to take forever to execute, we will have to wait forever to find out. This is called the <em>halting problem</em> and would be a huge problem for Ethereum if it were not addressed.</p>
</div>
<div class="paragraph">
<p>Because of the halting problem, the Ethereum world computer is at risk of being asked to execute a program that never stops. This could be by accident or malice. We have discussed that Ethereum acts like a single-threaded machine, without any scheduler, and so if it became stuck in an infinite loop this would mean it would become unusable.</p>
</div>
<div class="paragraph">
<p>However, with gas, there is a solution: if after a prespecified maximum amount of computation has been performed, the execution hasn&#x2019;t ended, the execution of the program is halted by the EVM. This makes the EVM a <em>quasi</em>&#x2013;Turing-complete machine: it can run any program you feed into it, but only if the program terminates within a particular amount of computation. That limit isn&#x2019;t fixed in Ethereum&#x2014;you can pay to increase it up to a maximum (called the &quot;block gas limit&quot;), and everyone can agree to increase that maximum over time. Nevertheless, at any one time, there is a limit in place, and transactions that consume too much gas while executing are <span class="keep-together">halted</span>.</p>
</div>
<div class="paragraph">
<p>In the following sections, we will look at gas and examine how it works in detail.</p>
</div>
</div>
<div class="sect2">
<h3 id="gas">Gas</h3>
<div class="paragraph">
<p><em>Gas</em> is Ethereum&#x2019;s unit for measuring the computational and storage resources required to perform actions on the Ethereum blockchain. In contrast to Bitcoin, whose transaction fees only take into account the size of a transaction in kilobytes, Ethereum must account for every computational step performed by transactions and smart contract code execution.</p>
</div>
<div class="paragraph">
<p>Each operation performed by a transaction or contract costs a fixed amount of gas. Some examples, from the Ethereum Yellow Paper:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Adding two numbers costs 3 gas</p>
</li>
<li>
<p>Calculating a Keccak-256 hash costs 30 gas + 6 gas for each 256 bits of data being hashed</p>
</li>
<li>
<p>Sending a transaction costs 21,000 gas</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Gas is a crucial component of Ethereum, and serves a dual role: as a buffer between the (volatile) price of Ethereum and the reward to miners for the work they do, and as a defense against denial-of-service attacks. To prevent accidental or malicious infinite loops or other computational wastage in the network, the initiator of each transaction is required to set a limit to the amount of computation they are willing to pay for. The gas system thereby disincentivizes attackers from sending &quot;spam&quot; transactions, as they must pay proportionately for the computational, bandwidth, and storage resources that they consume.</p>
</div>
<div class="sect3">
<h4 id="gas_accounting_execution">Gas Accounting During Execution</h4>
<div class="paragraph">
<p>When an EVM is needed to complete a transaction, in the first instance it is given a gas supply equal to the amount specified by the gas limit in the transaction. Every opcode that is executed has a cost in gas, and so the EVM&#x2019;s gas supply is reduced as the EVM steps through the program. Before each operation, the EVM checks that there is enough gas to pay for the operation&#x2019;s execution. If there isn&#x2019;t enough gas, execution is halted and the transaction is reverted.</p>
</div>
<div class="paragraph">
<p>If the EVM reaches the end of execution successfully, without running out of gas, the  gas cost used is paid to the miner as a transaction fee, converted to ether based on the gas price specified in the transaction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>miner fee = gas cost * gas price</pre>
</div>
</div>
<div class="paragraph">
<p>The gas remaining in the gas supply is refunded to the sender, again converted to ether based on the gas price specified in the transaction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>remaining gas = gas limit - gas cost
refunded ether = remaining gas * gas price</pre>
</div>
</div>
<div class="paragraph">
<p>If the transaction &#x201C;runs out of gas&#x201D; during execution, the operation is immediately terminated, raising an &#x201C;out of gas&#x201D; exception. The transaction is reverted and all changes to the state are rolled back.</p>
</div>
<div class="paragraph">
<p>Although the transaction was unsuccessful, the sender will be charged a transaction fee, as miners have already performed the computational work up to that point and must be compensated for doing so.</p>
</div>
</div>
<div class="sect3">
<h4 id="_gas_accounting_considerations">Gas Accounting Considerations</h4>
<div class="paragraph">
<p>The relative gas costs of the various operations that can be performed by the EVM have been carefully chosen to best protect the Ethereum blockchain from attack. You can see a detailed table of gas costs for different EVM opcodes in <a href="#evm_opcodes_table">[evm_opcodes_table]</a>.</p>
</div>
<div class="paragraph">
<p>More computationally intensive operations cost more gas. For example, executing the SHA3 function is 10 times more expensive (30 gas) than the ADD operation (3 gas). More importantly, some operations, such as EXP, require an additional payment based on the size of the operand. There is also a gas cost to using EVM memory and for storing data in a contract&#x2019;s on-chain storage.</p>
</div>
<div class="paragraph">
<p>The importance of matching gas cost to the real-world cost of resources was demonstrated in 2016 when an attacker found and exploited a mismatch in costs. The attack generated transactions that were very computationally expensive, and made the Ethereum mainnet almost grind to a halt. This mismatch was resolved by a hard fork (codenamed &quot;Tangerine Whistle&quot;) that tweaked the relative gas costs.</p>
</div>
</div>
<div class="sect3">
<h4 id="_gas_cost_versus_gas_price">Gas Cost Versus Gas Price</h4>
<div class="paragraph">
<p>While the gas <em>cost</em> is a measure of computation and storage used in the EVM, the gas itself also has a <em>price</em> measured in ether. When performing a transaction, the sender specifies the gas price they are willing to pay (in ether) for each unit of gas, allowing the market to decide the relationship between the price of ether and the cost of computing operations (as measured in gas):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>transaction fee = total gas used * gas price paid  (in ether)</pre>
</div>
</div>
<div class="paragraph">
<p>When constructing a new block, miners on the Ethereum network can choose among pending transactions by selecting those that offer to pay a higher gas price. Offering a higher gas price will therefore incentivize miners to include your transaction and get it confirmed faster.</p>
</div>
<div class="paragraph">
<p>In practice, the sender of a transaction will set a gas limit that is higher than or equal to the amount of gas expected to be used. If the gas limit is set higher than the amount of gas consumed, the sender will receive a refund of the excess amount, as miners are only compensated for the work they actually perform.</p>
</div>
<div class="paragraph">
<p>It is important to be clear about the distinction between the <em>gas cost</em> and the <em>gas price</em>. To recap:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gas cost is the number of units of gas required to perform a particular operation.</p>
</li>
<li>
<p>Gas price is the amount of ether you are willing to pay per unit of gas when you send your transaction to the Ethereum network.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>While gas has a price, it cannot be &quot;owned&quot; nor &quot;spent.&quot; Gas exists only inside the EVM, as a count of how much computational work is being performed. The sender is charged a transaction fee in ether, which is then converted to gas for EVM accounting and then back to ether as a transaction fee paid to the miners.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_negative_gas_costs">Negative gas costs</h5>
<div class="paragraph">
<p>Ethereum encourages the deletion of used storage variables and accounts by refunding some of the gas used during contract execution.</p>
</div>
<div class="paragraph">
<p>There are two operations in the EVM with negative gas costs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Deleting a contract (SELFDESTRUCT) is worth a refund of 24,000 gas.</p>
</li>
<li>
<p>Changing a storage address from a nonzero value to zero (SSTORE[x] = 0) is worth a refund of 15,000 gas.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To avoid exploitation of the refund mechanism, the maximum refund for a transaction is set to half the total amount of gas used (rounded down).</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_block_gas_limit">Block Gas Limit</h4>
<div class="paragraph">
<p>The block gas limit is the maximum amount of gas that may be consumed by all the transactions in a block, and constrains how many transactions can fit into a block.</p>
</div>
<div class="paragraph">
<p>For example, let&#x2019;s say we have 5 transactions whose gas limits have been set to 30,000, 30,000, 40,000, 50,000, and 50,000. If the block gas limit is 180,000, then any four of those transactions can fit in a block, while the fifth will have to wait for a future block. As previously discussed, miners decide which transactions to include in a block. Different miners are likely to select different combinations, mainly because they receive transactions from the network in a different order.</p>
</div>
<div class="paragraph">
<p>If a miner tries to include a transaction that requires more gas than the current block gas limit, the block will be rejected by the network. Most Ethereum clients will stop you from issuing such a transaction by giving a warning along the lines of &#x201C;transaction exceeds block gas limit.&#x201D; The block gas limit on the Ethereum mainnet is 8 million gas at the time of writing according to <a href="https://etherscan.io" class="bare" target="_blank">https://etherscan.io</a>, meaning that around 380 basic transactions (each consuming 21,000 gas) could fit into a block.</p>
</div>
<div class="sect4">
<h5 id="_who_decides_what_the_block_gas_limit_is">Who decides what the block gas limit is?</h5>
<div class="paragraph">
<p>The miners on the network collectively decide the block gas limit. Individuals who want to mine on the Ethereum network use a mining program, such as Ethminer, which connects to a Geth or Parity Ethereum client. The Ethereum protocol has a built-in mechanism where miners can vote on the gas limit so capacity can be increased or decreased in subsequent blocks. The miner of a block can vote to adjust the block gas limit by a factor of 1/1,024 (0.0976%) in either direction. The result of this is an adjustable block size based on the needs of the network at the time. This mechanism is coupled with a default mining strategy where miners vote on a gas limit that is at least 4.7 million gas, but which targets a value of 150% of the average of recent total gas usage per block (using a 1,024-block exponential moving average).</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conclusions">Conclusions</h3>
<div class="paragraph">
<p>In this chapter we have explored the Ethereum Virtual Machine, tracing the execution of various smart contracts and looking at how the EVM executes bytecode. We also looked at gas, the EVM&#x2019;s accounting mechanism, and saw how it solves the halting problem and protects Ethereum from denial-of-service attacks. Next, in <a href="#consensus">[consensus]</a>, we will look at the mechanism used by Ethereum to achieve decentralized consensus.</p>
</div>
</div>
</div>
</div>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="12dapps.html" class="navigation navigation-prev " aria-label="Previous page: Chapter 12: Decentralized Applications (DApps)">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="14consensus.html" class="navigation navigation-next " aria-label="Next page: Chapter 14: Consensus">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Chapter 13: The Ethereum Virtual Machine","level":"1.16","depth":1,"next":{"title":"Chapter 14: Consensus","level":"1.17","depth":1,"path":"14consensus.asciidoc","ref":"14consensus.asciidoc","articles":[]},"previous":{"title":"Chapter 12: Decentralized Applications (DApps)","level":"1.15","depth":1,"path":"12dapps.asciidoc","ref":"12dapps.asciidoc","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"13evm.asciidoc","mtime":"2019-08-27T09:18:17.277Z","type":"asciidoc"},"gitbook":{"version":"3.2.3","time":"2019-08-27T09:30:30.552Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

